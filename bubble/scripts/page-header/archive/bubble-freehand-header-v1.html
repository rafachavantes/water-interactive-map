<!-- ========================================
     WATER INFRASTRUCTURE MAP - FREEHAND DRAWING
     Bubble.io Page Header Script
     ======================================== -->

<!-- NO EXTERNAL CSS/JS NEEDED - All self-contained -->

<script>
/* ===== MAP CAPTURE & FREEHAND DRAWING SYSTEM =====
   Based on proven investigation report (freehand_draw_investigation_report.md)

   Features:
   - Captures Leaflet map instance to window.__leafy_found_map
   - Custom pointer-based freehand drawing (no Geoman dependency)
   - Douglas-Peucker path simplification (prevents 1MB coordinate limit)
   - GeoJSON output to window.__leafy_last_freehand
   - Bubble.io workflow integration callbacks

   Usage:
   1. This script auto-runs when page loads
   2. Call window.__leafy_freehand.start() to begin drawing
   3. Result available at window.__leafy_last_freehand (GeoJSON)
   4. Integrate with Bubble workflows via bubble_fn_* callbacks
*/

(function() {
  'use strict';

  // Prevent multiple installations
  if (window.__leafy_freehand_installed) {
    console.log('‚ö†Ô∏è Freehand header already installed, skipping...');
    return;
  }
  window.__leafy_freehand_installed = true;

  const MAX_CAPTURE_ATTEMPTS = 80;
  const RETRY_INTERVAL_MS = 250;

  // ===== DOUGLAS-PEUCKER PATH SIMPLIFICATION =====
  // Reduces coordinate count while maintaining shape accuracy
  // Critical for staying under Bubble's 1MB text field limit

  function douglasPeucker(points, tolerance) {
    if (points.length <= 2) return points;

    // Find point with maximum distance from line between first and last
    let maxDist = 0;
    let maxIndex = 0;
    const start = points[0];
    const end = points[points.length - 1];

    for (let i = 1; i < points.length - 1; i++) {
      const dist = perpendicularDistance(points[i], start, end);
      if (dist > maxDist) {
        maxDist = dist;
        maxIndex = i;
      }
    }

    // If max distance is greater than tolerance, recursively simplify
    if (maxDist > tolerance) {
      const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
      const right = douglasPeucker(points.slice(maxIndex), tolerance);
      return left.slice(0, -1).concat(right);
    } else {
      return [start, end];
    }
  }

  function perpendicularDistance(point, lineStart, lineEnd) {
    const [x0, y0] = point;
    const [x1, y1] = lineStart;
    const [x2, y2] = lineEnd;

    const dx = x2 - x1;
    const dy = y2 - y1;
    const mag = Math.sqrt(dx * dx + dy * dy);

    if (mag === 0) return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);

    const u = ((x0 - x1) * dx + (y0 - y1) * dy) / (mag * mag);
    const clampedU = Math.max(0, Math.min(1, u));

    const closestX = x1 + clampedU * dx;
    const closestY = y1 + clampedU * dy;

    return Math.sqrt((x0 - closestX) ** 2 + (y0 - closestY) ** 2);
  }

  window.simplifyPath = function(points, tolerance = 0.0001) {
    if (!points || points.length < 2) return points;
    return douglasPeucker(points, tolerance);
  };

  // ===== MAP INSTANCE CAPTURE =====

  function isMapLike(obj) {
    try {
      return obj &&
             typeof obj.getCenter === 'function' &&
             obj._container !== undefined;
    } catch (e) {
      return false;
    }
  }

  function captureMap(map) {
    if (!isMapLike(map)) {
      console.warn('‚ö†Ô∏è captureMap: not a valid Leaflet map', map);
      return false;
    }

    window.__leafy_found_map = map;
    console.log('‚úÖ Leaflet map captured -> window.__leafy_found_map', map);

    // Notify Bubble that map is ready
    if (typeof window.bubble_fn_mapReady === 'function') {
      window.bubble_fn_mapReady();
    }

    return true;
  }

  // Hook L.Map.prototype.initialize to capture map on creation
  function installLeafletHook() {
    if (!(window.L && window.L.Map)) return false;
    if (window.__leafy_map_hook_installed) return true;

    const originalInit = window.L.Map.prototype.initialize;

    window.L.Map.prototype.initialize = function(id, options) {
      const result = originalInit.apply(this, arguments);

      // Check if this is our target map
      const container = this._container || (this.getContainer && this.getContainer());
      const leafyEl = document.querySelector('#leafy_main') ||
                     document.querySelector('.leaflet-container') ||
                     document.querySelector('[id^="leafy"]');

      if (container && leafyEl &&
          (container === leafyEl ||
           leafyEl.contains(container) ||
           (container.contains && container.contains(leafyEl)))) {
        captureMap(this);
      }

      return result;
    };

    // Also hook L.map factory if it exists
    if (typeof window.L.map === 'function') {
      const originalFactory = window.L.map;
      window.L.map = function() {
        const map = originalFactory.apply(this, arguments);

        const container = map._container || (map.getContainer && map.getContainer());
        const leafyEl = document.querySelector('#leafy_main') ||
                       document.querySelector('.leaflet-container') ||
                       document.querySelector('[id^="leafy"]');

        if (container && leafyEl &&
            (container === leafyEl ||
             leafyEl.contains(container) ||
             (container.contains && container.contains(leafyEl)))) {
          captureMap(map);
        }

        return map;
      };
    }

    window.__leafy_map_hook_installed = true;
    console.log('ü™ù Leaflet map hooks installed');
    return true;
  }

  // Try to find already-created map
  function tryFindExistingMap() {
    try {
      // Check if already captured
      if (window.__leafy_found_map && isMapLike(window.__leafy_found_map)) {
        return window.__leafy_found_map;
      }

      // Search window properties
      for (const key of Object.keys(window)) {
        try {
          const val = window[key];
          if (isMapLike(val)) {
            captureMap(val);
            return val;
          }
          // Check nested properties (Bubble plugin pattern)
          if (val && typeof val === 'object') {
            if (isMapLike(val.mymap)) {
              captureMap(val.mymap);
              return val.mymap;
            }
            if (val.data && isMapLike(val.data.mymap)) {
              captureMap(val.data.mymap);
              return val.data.mymap;
            }
          }
        } catch (e) {
          // Skip inaccessible properties
        }
      }

      // DOM container search
      const leafyEl = document.querySelector('#leafy_main') ||
                     document.querySelector('.leaflet-container') ||
                     document.querySelector('[id^="leafy"]');

      if (leafyEl) {
        // Check jQuery data if available
        if (window.jQuery) {
          try {
            const jqData = window.jQuery(leafyEl).data() || {};
            for (const key of Object.keys(jqData)) {
              const val = jqData[key];
              if (val && val.data && isMapLike(val.data.mymap)) {
                captureMap(val.data.mymap);
                return val.data.mymap;
              }
            }
          } catch (e) {
            // jQuery not available or error
          }
        }

        // Walk up DOM tree looking for map instance
        let parent = leafyEl;
        const mapProps = ['_leaflet_map', '__leaflet_map', 'leafyMap',
                         'leafletMap', 'mymap', 'map', 'instance'];

        for (let i = 0; parent && i < 8; i++) {
          for (const prop of mapProps) {
            if (parent[prop] && isMapLike(parent[prop])) {
              captureMap(parent[prop]);
              return parent[prop];
            }
            if (parent[prop] && parent[prop].data && isMapLike(parent[prop].data.mymap)) {
              captureMap(parent[prop].data.mymap);
              return parent[prop].data.mymap;
            }
          }
          parent = parent.parentElement;
        }
      }
    } catch (e) {
      console.warn('tryFindExistingMap error:', e);
    }

    return null;
  }

  // ===== CUSTOM FREEHAND DRAWING TOOL =====
  // Based on proven pointer event implementation from investigation report

  window.__leafy_freehand = {
    isDrawing: false,
    currentPath: [],
    previewLayer: null,
    _eventHandlers: {},

    start: function() {
      const map = window.__leafy_found_map;

      if (!map || !isMapLike(map)) {
        console.error('‚ùå Cannot start freehand: map not found. Run window.__leafy_try_capture_now() to retry.');
        return;
      }

      const self = this;

      // Disable map dragging during drawing
      map.dragging.disable();
      map.getContainer().style.cursor = 'crosshair';

      console.log('üé® Freehand mode enabled. Click and drag to draw.');

      const onPointerDown = function(e) {
        self.isDrawing = true;
        self.currentPath = [[e.latlng.lat, e.latlng.lng]];

        const onPointerMove = function(e) {
          if (!self.isDrawing) return;

          self.currentPath.push([e.latlng.lat, e.latlng.lng]);

          // Update preview layer
          if (self.previewLayer) {
            map.removeLayer(self.previewLayer);
          }

          self.previewLayer = L.polyline(self.currentPath, {
            color: '#3B82F6',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 5'
          }).addTo(map);
        };

        const onPointerUp = function(e) {
          self.isDrawing = false;

          // Remove event listeners
          map.off('pointermove', onPointerMove);
          map.off('pointerup', onPointerUp);

          // Re-enable map dragging
          map.dragging.enable();
          map.getContainer().style.cursor = '';

          if (self.currentPath.length >= 2) {
            // Simplify path to reduce coordinate count
            const simplified = window.simplifyPath(self.currentPath, 0.0001);

            console.log(`üìâ Path simplified: ${self.currentPath.length} -> ${simplified.length} points`);

            // Create GeoJSON (coordinates in [lng, lat] format for GeoJSON spec)
            const geojson = {
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: simplified.map(p => [p[1], p[0]]) // [lng, lat]
              },
              properties: {
                tool: 'freehand',
                color: '#3B82F6',
                strokeWeight: 3,
                originalPointCount: self.currentPath.length,
                simplifiedPointCount: simplified.length
              }
            };

            // Store result
            window.__leafy_last_freehand = geojson;
            console.log('‚úÖ Freehand drawing complete -> window.__leafy_last_freehand', geojson);

            // Clear preview layer
            if (self.previewLayer) {
              map.removeLayer(self.previewLayer);
              self.previewLayer = null;
            }

            // Notify Bubble workflow
            if (typeof window.bubble_fn_freehandComplete === 'function') {
              window.bubble_fn_freehandComplete(JSON.stringify(geojson));
            }
          } else {
            console.log('‚ö†Ô∏è Freehand drawing too short (< 2 points), discarded.');
          }

          // Cleanup
          self.currentPath = [];
          map.off('pointerdown', onPointerDown);
        };

        map.on('pointermove', onPointerMove);
        map.on('pointerup', onPointerUp);
      };

      map.once('pointerdown', onPointerDown);

      // Store reference for cleanup
      this._eventHandlers.onPointerDown = onPointerDown;
    },

    stop: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;

      this.isDrawing = false;
      this.currentPath = [];

      // Remove preview layer
      if (this.previewLayer) {
        map.removeLayer(this.previewLayer);
        this.previewLayer = null;
      }

      // Re-enable map interaction
      map.dragging.enable();
      map.getContainer().style.cursor = '';

      // Remove event listeners
      if (this._eventHandlers.onPointerDown) {
        map.off('pointerdown', this._eventHandlers.onPointerDown);
      }

      console.log('üõë Freehand mode stopped.');
    },

    clearLayers: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;

      if (this.previewLayer) {
        map.removeLayer(this.previewLayer);
        this.previewLayer = null;
      }

      console.log('üßπ Freehand layers cleared.');
    }
  };

  // ===== HELPER FUNCTIONS FOR BUBBLE WORKFLOWS =====

  window.createGeoJSON = function(type, coordinates, properties) {
    return {
      type: "Feature",
      geometry: { type: type, coordinates: coordinates },
      properties: properties || {}
    };
  };

  window.calculateCenter = function(coordinates) {
    if (!coordinates || coordinates.length === 0) return null;

    let sumLat = 0, sumLng = 0;

    // Handle different coordinate formats
    if (Array.isArray(coordinates[0])) {
      // Array of [lat, lng] or [lng, lat]
      coordinates.forEach(coord => {
        sumLat += coord[0];
        sumLng += coord[1];
      });
    } else {
      // Single [lat, lng]
      return coordinates;
    }

    return [sumLat / coordinates.length, sumLng / coordinates.length];
  };

  // ===== AUTO-CAPTURE SYSTEM =====

  let captureAttempts = 0;
  const captureInterval = setInterval(function() {
    captureAttempts++;

    // Install hook as soon as Leaflet is available
    if (window.L && window.L.Map) {
      installLeafletHook();
    }

    // Try to find existing map
    const found = tryFindExistingMap();

    if (found) {
      clearInterval(captureInterval);
      console.log('üéâ Map capture successful! Freehand tool ready.');
      return;
    }

    if (captureAttempts >= MAX_CAPTURE_ATTEMPTS) {
      clearInterval(captureInterval);
      console.log('‚è±Ô∏è Map capture attempts exhausted. Hook remains active for future map creation.');
    }
  }, RETRY_INTERVAL_MS);

  // Additional capture attempts on DOM events
  document.addEventListener('DOMContentLoaded', function() {
    tryFindExistingMap();
    installLeafletHook();
  });

  window.addEventListener('load', function() {
    tryFindExistingMap();
    installLeafletHook();
  });

  // Manual trigger function for debugging
  window.__leafy_try_capture_now = function() {
    tryFindExistingMap();
    installLeafletHook();
    console.log('üîÑ Manual capture attempt triggered.');
  };

  console.log('üöÄ Leafy Freehand Drawing System initialized');
  console.log('üìö Available commands:');
  console.log('  - window.__leafy_freehand.start()  ‚Üí Begin freehand drawing');
  console.log('  - window.__leafy_freehand.stop()   ‚Üí Cancel freehand drawing');
  console.log('  - window.__leafy_last_freehand     ‚Üí Get last drawing result (GeoJSON)');
  console.log('  - window.__leafy_found_map         ‚Üí Access map instance');
  console.log('  - window.__leafy_try_capture_now() ‚Üí Retry map capture manually');

})();
</script>

<!-- ===== BUBBLE INTEGRATION CALLBACKS =====
     Define these in your Bubble workflows to receive drawing data:

     window.bubble_fn_mapReady = function() {
       // Called when map is captured and ready
       console.log('Bubble: Map is ready!');
     };

     window.bubble_fn_freehandComplete = function(geojsonString) {
       // Called when freehand drawing is complete
       var geojson = JSON.parse(geojsonString);
       console.log('Bubble: Freehand complete', geojson);
       // Trigger your "Save Drawing" workflow here
     };
-->
