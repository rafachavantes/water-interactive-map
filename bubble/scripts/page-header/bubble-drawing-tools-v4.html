<!-- ========================================
     WATER INFRASTRUCTURE MAP - DRAWING TOOLS v4
     Bubble.io Page Header Script
     Freehand + Point + Line + Area tools
     WITH AUTO-RENDERING after drawing completes
     ======================================== -->

<script>
/* ===== MAP CAPTURE & DRAWING TOOLS SYSTEM v4 =====
   Freehand + Point + Line + Area tools
   Now with automatic rendering option
*/

(function() {
  'use strict';

  if (window.__leafy_drawing_tools_installed) {
    console.log('‚ö†Ô∏è Drawing tools already installed, skipping...');
    return;
  }
  window.__leafy_drawing_tools_installed = true;

  const MAX_CAPTURE_ATTEMPTS = 80;
  const RETRY_INTERVAL_MS = 250;

  // ===== DOUGLAS-PEUCKER PATH SIMPLIFICATION =====

  function douglasPeucker(points, tolerance) {
    if (points.length <= 2) return points;
    let maxDist = 0;
    let maxIndex = 0;
    const start = points[0];
    const end = points[points.length - 1];
    for (let i = 1; i < points.length - 1; i++) {
      const dist = perpendicularDistance(points[i], start, end);
      if (dist > maxDist) {
        maxDist = dist;
        maxIndex = i;
      }
    }
    if (maxDist > tolerance) {
      const left = douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
      const right = douglasPeucker(points.slice(maxIndex), tolerance);
      return left.slice(0, -1).concat(right);
    } else {
      return [start, end];
    }
  }

  function perpendicularDistance(point, lineStart, lineEnd) {
    const [x0, y0] = point;
    const [x1, y1] = lineStart;
    const [x2, y2] = lineEnd;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag === 0) return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);
    const u = ((x0 - x1) * dx + (y0 - y1) * dy) / (mag * mag);
    const clampedU = Math.max(0, Math.min(1, u));
    const closestX = x1 + clampedU * dx;
    const closestY = y1 + clampedU * dy;
    return Math.sqrt((x0 - closestX) ** 2 + (y0 - closestY) ** 2);
  }

  window.simplifyPath = function(points, tolerance = 0.0001) {
    if (!points || points.length < 2) return points;
    return douglasPeucker(points, tolerance);
  };

  // ===== MAP INSTANCE CAPTURE =====

  function isMapLike(obj) {
    try {
      return obj && typeof obj.getCenter === 'function' && obj._container !== undefined;
    } catch (e) {
      return false;
    }
  }

  function captureMap(map) {
    if (!isMapLike(map)) {
      console.warn('‚ö†Ô∏è captureMap: not a valid Leaflet map', map);
      return false;
    }
    window.__leafy_found_map = map;
    console.log('‚úÖ Leaflet map captured -> window.__leafy_found_map', map);
    if (typeof window.bubble_fn_mapReady === 'function') {
      window.bubble_fn_mapReady();
    }
    return true;
  }

  function installLeafletHook() {
    if (!(window.L && window.L.Map)) return false;
    if (window.__leafy_map_hook_installed) return true;

    const originalInit = window.L.Map.prototype.initialize;
    window.L.Map.prototype.initialize = function(id, options) {
      const result = originalInit.apply(this, arguments);
      const container = this._container || (this.getContainer && this.getContainer());
      const leafyEl = document.querySelector('#leafy_main') || document.querySelector('.leaflet-container') || document.querySelector('[id^="leafy"]');
      if (container && leafyEl && (container === leafyEl || leafyEl.contains(container) || (container.contains && container.contains(leafyEl)))) {
        captureMap(this);
      }
      return result;
    };

    if (typeof window.L.map === 'function') {
      const originalFactory = window.L.map;
      window.L.map = function() {
        const map = originalFactory.apply(this, arguments);
        const container = map._container || (map.getContainer && map.getContainer());
        const leafyEl = document.querySelector('#leafy_main') || document.querySelector('.leaflet-container') || document.querySelector('[id^="leafy"]');
        if (container && leafyEl && (container === leafyEl || leafyEl.contains(container) || (container.contains && container.contains(leafyEl)))) {
          captureMap(map);
        }
        return map;
      };
    }

    window.__leafy_map_hook_installed = true;
    console.log('ü™ù Leaflet map hooks installed');
    return true;
  }

  function tryFindExistingMap() {
    try {
      if (window.__leafy_found_map && isMapLike(window.__leafy_found_map)) return window.__leafy_found_map;
      for (const key of Object.keys(window)) {
        try {
          const val = window[key];
          if (isMapLike(val)) { captureMap(val); return val; }
          if (val && typeof val === 'object') {
            if (isMapLike(val.mymap)) { captureMap(val.mymap); return val.mymap; }
            if (val.data && isMapLike(val.data.mymap)) { captureMap(val.data.mymap); return val.data.mymap; }
          }
        } catch (e) {}
      }
      const leafyEl = document.querySelector('#leafy_main') || document.querySelector('.leaflet-container') || document.querySelector('[id^="leafy"]');
      if (leafyEl) {
        if (window.jQuery) {
          try {
            const jqData = window.jQuery(leafyEl).data() || {};
            for (const key of Object.keys(jqData)) {
              const val = jqData[key];
              if (val && val.data && isMapLike(val.data.mymap)) { captureMap(val.data.mymap); return val.data.mymap; }
            }
          } catch (e) {}
        }
        let parent = leafyEl;
        const mapProps = ['_leaflet_map', '__leaflet_map', 'leafyMap', 'leafletMap', 'mymap', 'map', 'instance'];
        for (let i = 0; parent && i < 8; i++) {
          for (const prop of mapProps) {
            if (parent[prop] && isMapLike(parent[prop])) { captureMap(parent[prop]); return parent[prop]; }
            if (parent[prop] && parent[prop].data && isMapLike(parent[prop].data.mymap)) { captureMap(parent[prop].data.mymap); return parent[prop].data.mymap; }
          }
          parent = parent.parentElement;
        }
      }
    } catch (e) { console.warn('tryFindExistingMap error:', e); }
    return null;
  }

  // ===== CUSTOM FREEHAND DRAWING TOOL =====

  window.__leafy_freehand = {
    isDrawing: false,
    currentPath: [],
    previewLayer: null,
    autoRender: false,  // NEW: Set to true to keep drawing on map
    _handlers: {},

    start: function(options) {
      options = options || {};
      const map = window.__leafy_found_map;

      if (!map || !isMapLike(map)) {
        console.error('‚ùå Map not found. Run window.__leafy_try_capture_now()');
        return;
      }

      const self = this;
      const container = map.getContainer();

      // Set auto-render option
      if (options.autoRender !== undefined) {
        self.autoRender = options.autoRender;
      }

      map.dragging.disable();
      container.style.cursor = 'crosshair';

      console.log('üé® Freehand mode enabled. Click and drag to draw.');
      if (self.autoRender) console.log('üñºÔ∏è Auto-render: ON (drawing will stay on map)');

      const onMouseDown = function(e) {
        e.preventDefault();
        const containerPoint = map.mouseEventToContainerPoint(e);
        const latlng = map.containerPointToLatLng(containerPoint);
        self.isDrawing = true;
        self.currentPath = [[latlng.lat, latlng.lng]];

        const onMouseMove = function(e) {
          if (!self.isDrawing) return;
          const containerPoint = map.mouseEventToContainerPoint(e);
          const latlng = map.containerPointToLatLng(containerPoint);
          self.currentPath.push([latlng.lat, latlng.lng]);

          if (self.previewLayer) map.removeLayer(self.previewLayer);
          self.previewLayer = L.polyline(self.currentPath, {
            color: '#3B82F6',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 5'
          }).addTo(map);
        };

        const onMouseUp = function(e) {
          self.isDrawing = false;
          container.removeEventListener('mousemove', onMouseMove);
          container.removeEventListener('mouseup', onMouseUp);
          document.removeEventListener('mouseup', onMouseUp);
          map.dragging.enable();
          container.style.cursor = '';

          if (self.currentPath.length >= 2) {
            const simplified = window.simplifyPath(self.currentPath, 0.0001);
            console.log(`üìâ Path simplified: ${self.currentPath.length} -> ${simplified.length} points`);

            const geojson = {
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: simplified.map(p => [p[1], p[0]])
              },
              properties: {
                tool: 'freehand',
                color: '#3B82F6',
                strokeWeight: 3,
                originalPointCount: self.currentPath.length,
                simplifiedPointCount: simplified.length
              }
            };

            window.__leafy_last_freehand = geojson;
            console.log('‚úÖ Freehand complete -> window.__leafy_last_freehand');

            // Clear dashed preview
            if (self.previewLayer) {
              map.removeLayer(self.previewLayer);
              self.previewLayer = null;
            }

            // AUTO-RENDER: Draw permanent layer if enabled
            if (self.autoRender) {
              const leafletCoords = geojson.geometry.coordinates.map(c => [c[1], c[0]]);
              const permanentLayer = L.polyline(leafletCoords, {
                color: geojson.properties.color,
                weight: geojson.properties.strokeWeight,
                opacity: 1  // Solid line
              }).addTo(map);

              console.log('üñºÔ∏è Auto-rendered on map (permanent)');

              // Store reference
              if (!window.__leafy_rendered_layers) window.__leafy_rendered_layers = [];
              window.__leafy_rendered_layers.push(permanentLayer);
            }

            // Notify Bubble
            if (typeof window.bubble_fn_freehandComplete === 'function') {
              window.bubble_fn_freehandComplete(JSON.stringify(geojson));
            }
          } else {
            console.log('‚ö†Ô∏è Drawing too short, discarded.');
            if (self.previewLayer) {
              map.removeLayer(self.previewLayer);
              self.previewLayer = null;
            }
          }

          self.currentPath = [];
          container.removeEventListener('mousedown', onMouseDown);
        };

        container.addEventListener('mousemove', onMouseMove);
        container.addEventListener('mouseup', onMouseUp);
        document.addEventListener('mouseup', onMouseUp);
        self._handlers.onMouseMove = onMouseMove;
        self._handlers.onMouseUp = onMouseUp;
      };

      container.addEventListener('mousedown', onMouseDown);
      self._handlers.onMouseDown = onMouseDown;
    },

    stop: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      const container = map.getContainer();
      this.isDrawing = false;
      this.currentPath = [];
      if (this.previewLayer) {
        map.removeLayer(this.previewLayer);
        this.previewLayer = null;
      }
      map.dragging.enable();
      container.style.cursor = '';
      if (this._handlers.onMouseDown) container.removeEventListener('mousedown', this._handlers.onMouseDown);
      if (this._handlers.onMouseMove) container.removeEventListener('mousemove', this._handlers.onMouseMove);
      if (this._handlers.onMouseUp) {
        container.removeEventListener('mouseup', this._handlers.onMouseUp);
        document.removeEventListener('mouseup', this._handlers.onMouseUp);
      }
      this._handlers = {};
      console.log('üõë Freehand stopped.');
    },

    clearLayers: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      if (this.previewLayer) {
        map.removeLayer(this.previewLayer);
        this.previewLayer = null;
      }
      console.log('üßπ Preview layers cleared.');
    },

    clearAllRendered: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      if (window.__leafy_rendered_layers) {
        window.__leafy_rendered_layers.forEach(layer => map.removeLayer(layer));
        window.__leafy_rendered_layers = [];
        console.log('üßπ All rendered layers cleared.');
      }
    }
  };

  // ===== POINT TOOL (Single Click Marker) =====

  window.__leafy_point = {
    autoRender: false,
    _handler: null,

    start: function(options) {
      options = options || {};
      const map = window.__leafy_found_map;

      if (!map || !isMapLike(map)) {
        console.error('‚ùå Map not found. Run window.__leafy_try_capture_now()');
        return;
      }

      const self = this;
      const container = map.getContainer();

      // Set auto-render option
      if (options.autoRender !== undefined) {
        self.autoRender = options.autoRender;
      }

      container.style.cursor = 'crosshair';
      console.log('üìç Point mode enabled. Click to place marker.');
      if (self.autoRender) console.log('üñºÔ∏è Auto-render: ON (marker will stay on map)');

      const onClick = function(e) {
        const latlng = e.latlng;

        // Create GeoJSON Point
        const geojson = {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [latlng.lng, latlng.lat]
          },
          properties: {
            tool: 'point',
            color: '#3B82F6'
          }
        };

        window.__leafy_last_point = geojson;
        console.log('‚úÖ Point placed -> window.__leafy_last_point', geojson);

        // AUTO-RENDER: Draw marker if enabled
        if (self.autoRender) {
          const marker = L.marker([latlng.lat, latlng.lng], {
            icon: L.icon({
              iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
              iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
              shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            })
          }).addTo(map);

          console.log('üñºÔ∏è Auto-rendered marker on map');

          // Store reference
          if (!window.__leafy_rendered_layers) window.__leafy_rendered_layers = [];
          window.__leafy_rendered_layers.push(marker);
        }

        // Notify Bubble with 3 outputs (matching freehand pattern)
        // output1 = properties (full GeoJSON Feature)
        // output2 = coordinates [[lng, lat]] - wrapped in array for consistency
        // output3 = marker_position ([lat, lng] - reversed!)
        if (typeof window.bubble_fn_pointComplete === 'function') {
          window.bubble_fn_pointComplete({
            output1: JSON.stringify(geojson),                              // Full GeoJSON Feature
            output2: JSON.stringify([geojson.geometry.coordinates]),       // [[lng, lat]] - array of pairs
            output3: JSON.stringify([latlng.lat, latlng.lng])             // [lat, lng] - marker position
          });
        }

        // Cleanup
        container.style.cursor = '';
        map.off('click', onClick);
        self._handler = null;
      };

      map.once('click', onClick);
      self._handler = onClick;
    },

    stop: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      const container = map.getContainer();
      container.style.cursor = '';
      if (this._handler) {
        map.off('click', this._handler);
        this._handler = null;
      }
      console.log('üõë Point tool stopped.');
    }
  };

  // ===== LINE TOOL (Click-based Polyline) =====

  window.__leafy_line = {
    points: [],
    previewLayer: null,
    markers: [],
    autoRender: false,
    _handlers: {},

    start: function(options) {
      options = options || {};
      const map = window.__leafy_found_map;

      if (!map || !isMapLike(map)) {
        console.error('‚ùå Map not found. Run window.__leafy_try_capture_now()');
        return;
      }

      const self = this;
      const container = map.getContainer();

      // Set auto-render option
      if (options.autoRender !== undefined) {
        self.autoRender = options.autoRender;
      }

      container.style.cursor = 'crosshair';
      console.log('üìè Line mode enabled. Click to add vertices, double-click to finish.');
      if (self.autoRender) console.log('üñºÔ∏è Auto-render: ON (line will stay on map)');

      const onClick = function(e) {
        self.points.push([e.latlng.lat, e.latlng.lng]);

        // Add vertex marker
        const marker = L.circleMarker(e.latlng, {
          radius: 5,
          color: '#3B82F6',
          fillColor: '#fff',
          fillOpacity: 1,
          weight: 2
        }).addTo(map);
        self.markers.push(marker);

        console.log(`üìç Vertex ${self.points.length} added`);

        // Update preview line
        if (self.points.length >= 2) {
          if (self.previewLayer) map.removeLayer(self.previewLayer);
          self.previewLayer = L.polyline(self.points, {
            color: '#3B82F6',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 5'
          }).addTo(map);
        }
      };

      const onDblClick = function(e) {
        L.DomEvent.stop(e);
        console.log('‚úÖ Line complete (double-click detected)');
        self.finish();
      };

      map.on('click', onClick);
      map.on('dblclick', onDblClick);

      // Store for cleanup
      self._handlers.onClick = onClick;
      self._handlers.onDblClick = onDblClick;
    },

    finish: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;

      if (this.points.length >= 2) {
        const geojson = {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: this.points.map(p => [p[1], p[0]]) // [lng, lat]
          },
          properties: {
            tool: 'line',
            color: '#3B82F6',
            strokeWeight: 3
          }
        };

        window.__leafy_last_line = geojson;
        console.log('‚úÖ Line created -> window.__leafy_last_line', geojson);

        // Clear preview
        if (this.previewLayer) {
          map.removeLayer(this.previewLayer);
          this.previewLayer = null;
        }

        // AUTO-RENDER: Draw permanent layer if enabled
        if (this.autoRender) {
          const leafletCoords = geojson.geometry.coordinates.map(c => [c[1], c[0]]);
          const permanentLayer = L.polyline(leafletCoords, {
            color: geojson.properties.color,
            weight: geojson.properties.strokeWeight,
            opacity: 1
          }).addTo(map);

          console.log('üñºÔ∏è Auto-rendered on map (permanent)');

          // Store reference
          if (!window.__leafy_rendered_layers) window.__leafy_rendered_layers = [];
          window.__leafy_rendered_layers.push(permanentLayer);
        }

        // Notify Bubble
        if (typeof window.bubble_fn_lineComplete === 'function') {
          window.bubble_fn_lineComplete(JSON.stringify(geojson));
        }
      } else {
        console.log('‚ö†Ô∏è Line needs at least 2 points, discarded.');
      }

      this.cleanup();
    },

    stop: function() {
      console.log('üõë Line tool stopped.');
      this.cleanup();
    },

    cleanup: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      const container = map.getContainer();

      // Remove event listeners
      if (this._handlers.onClick) map.off('click', this._handlers.onClick);
      if (this._handlers.onDblClick) map.off('dblclick', this._handlers.onDblClick);

      // Clear visual elements
      this.markers.forEach(m => map.removeLayer(m));
      if (this.previewLayer) map.removeLayer(this.previewLayer);

      // Reset state
      this.points = [];
      this.markers = [];
      this.previewLayer = null;
      this._handlers = {};
      container.style.cursor = '';
    }
  };

  // ===== AREA TOOL (Click-based Polygon) =====

  window.__leafy_area = {
    points: [],
    previewLayer: null,
    markers: [],
    autoRender: false,
    _handlers: {},

    start: function(options) {
      options = options || {};
      const map = window.__leafy_found_map;

      if (!map || !isMapLike(map)) {
        console.error('‚ùå Map not found. Run window.__leafy_try_capture_now()');
        return;
      }

      const self = this;
      const container = map.getContainer();

      // Set auto-render option
      if (options.autoRender !== undefined) {
        self.autoRender = options.autoRender;
      }

      container.style.cursor = 'crosshair';
      console.log('üî∂ Area mode enabled. Click to add vertices, double-click to close polygon.');
      if (self.autoRender) console.log('üñºÔ∏è Auto-render: ON (polygon will stay on map)');

      const onClick = function(e) {
        self.points.push([e.latlng.lat, e.latlng.lng]);

        // Add vertex marker
        const marker = L.circleMarker(e.latlng, {
          radius: 5,
          color: '#3B82F6',
          fillColor: '#fff',
          fillOpacity: 1,
          weight: 2
        }).addTo(map);
        self.markers.push(marker);

        console.log(`üìç Vertex ${self.points.length} added`);

        // Update preview polygon
        if (self.points.length >= 3) {
          if (self.previewLayer) map.removeLayer(self.previewLayer);
          self.previewLayer = L.polygon(self.points, {
            color: '#3B82F6',
            weight: 3,
            opacity: 0.8,
            fillOpacity: 0.2,
            dashArray: '5, 5'
          }).addTo(map);
        } else if (self.points.length === 2) {
          // Show line preview before 3rd point
          if (self.previewLayer) map.removeLayer(self.previewLayer);
          self.previewLayer = L.polyline(self.points, {
            color: '#3B82F6',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 5'
          }).addTo(map);
        }
      };

      const onDblClick = function(e) {
        L.DomEvent.stop(e);
        console.log('‚úÖ Polygon complete (double-click detected)');
        self.finish();
      };

      map.on('click', onClick);
      map.on('dblclick', onDblClick);

      // Store for cleanup
      self._handlers.onClick = onClick;
      self._handlers.onDblClick = onDblClick;
    },

    finish: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;

      if (this.points.length >= 3) {
        const geojson = {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [this.points.map(p => [p[1], p[0]])] // Array of rings, [lng, lat]
          },
          properties: {
            tool: 'area',
            color: '#3B82F6',
            strokeWeight: 3,
            fillOpacity: 0.3
          }
        };

        window.__leafy_last_area = geojson;
        console.log('‚úÖ Polygon created -> window.__leafy_last_area', geojson);

        // Clear preview
        if (this.previewLayer) {
          map.removeLayer(this.previewLayer);
          this.previewLayer = null;
        }

        // AUTO-RENDER: Draw permanent layer if enabled
        if (this.autoRender) {
          const leafletCoords = geojson.geometry.coordinates[0].map(c => [c[1], c[0]]);
          const permanentLayer = L.polygon(leafletCoords, {
            color: geojson.properties.color,
            weight: geojson.properties.strokeWeight,
            fillOpacity: geojson.properties.fillOpacity,
            opacity: 1
          }).addTo(map);

          console.log('üñºÔ∏è Auto-rendered on map (permanent)');

          // Store reference
          if (!window.__leafy_rendered_layers) window.__leafy_rendered_layers = [];
          window.__leafy_rendered_layers.push(permanentLayer);
        }

        // Notify Bubble
        if (typeof window.bubble_fn_areaComplete === 'function') {
          window.bubble_fn_areaComplete(JSON.stringify(geojson));
        }
      } else {
        console.log('‚ö†Ô∏è Polygon needs at least 3 points, discarded.');
      }

      this.cleanup();
    },

    stop: function() {
      console.log('üõë Area tool stopped.');
      this.cleanup();
    },

    cleanup: function() {
      const map = window.__leafy_found_map;
      if (!map || !isMapLike(map)) return;
      const container = map.getContainer();

      // Remove event listeners
      if (this._handlers.onClick) map.off('click', this._handlers.onClick);
      if (this._handlers.onDblClick) map.off('dblclick', this._handlers.onDblClick);

      // Clear visual elements
      this.markers.forEach(m => map.removeLayer(m));
      if (this.previewLayer) map.removeLayer(this.previewLayer);

      // Reset state
      this.points = [];
      this.markers = [];
      this.previewLayer = null;
      this._handlers = {};
      container.style.cursor = '';
    }
  };

  // ===== UNIVERSAL UTILITY FUNCTIONS =====

  // Stop all drawing tools at once
  window.stopAllDrawingTools = function() {
    if (window.__leafy_point) window.__leafy_point.stop();
    if (window.__leafy_line) window.__leafy_line.stop();
    if (window.__leafy_freehand) window.__leafy_freehand.stop();
    if (window.__leafy_area) window.__leafy_area.stop();
    console.log('üõë All drawing tools stopped');
  };

  // Remove any drawing type from map by ID
  window.removeDrawing = function(drawingId) {
    if (!window.__drawing_layers || !window.__drawing_layers[drawingId]) {
      console.warn('‚ö†Ô∏è Drawing not found:', drawingId);
      return;
    }

    const drawing = window.__drawing_layers[drawingId];
    const map = window.__leafy_found_map;

    if (map) {
      if (drawing.layer) map.removeLayer(drawing.layer);
      if (drawing.marker) map.removeLayer(drawing.marker);
    }

    delete window.__drawing_layers[drawingId];
    console.log('üóëÔ∏è Drawing removed:', drawingId, '(type:', drawing.type + ')');
  };

  // Update drawing color for any type (Point, Line, Polygon)
  window.updateDrawingColor = function(drawingId, newColor) {
    if (!window.__drawing_layers || !window.__drawing_layers[drawingId]) {
      console.warn('‚ö†Ô∏è Drawing not found:', drawingId);
      return;
    }

    const drawing = window.__drawing_layers[drawingId];
    const map = window.__leafy_found_map;

    if (!map) {
      console.error('‚ùå Map not found');
      return;
    }

    // Update line/polygon stroke color
    if (drawing.layer && drawing.layer.setStyle) {
      drawing.layer.setStyle({ color: newColor });
    }

    // Update center marker color (for polyline/polygon)
    if (drawing.marker && drawing.type !== 'point') {
      const latlng = drawing.marker.getLatLng();

      // Remove old marker
      map.removeLayer(drawing.marker);

      // Create new marker with updated color (SVG pin)
      const newMarker = L.marker(latlng, {
        icon: L.divIcon({
          html: '<svg width="25" height="41" viewBox="0 0 25 41" xmlns="http://www.w3.org/2000/svg">' +
            '<path d="M12.5 0C5.6 0 0 5.6 0 12.5C0 21.9 12.5 41 12.5 41S25 21.9 25 12.5C25 5.6 19.4 0 12.5 0Z" ' +
            'fill="' + newColor + '" stroke="white" stroke-width="2"/>' +
            '<circle cx="12.5" cy="12.5" r="4" fill="white"/>' +
            '</svg>',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          className: 'drawing-marker-center'
        })
      }).addTo(map);

      // Re-attach click handler
      newMarker.on('click', function(e) {
        L.DomEvent.stopPropagation(e);
        if (window.bubble_fn_drawing_selected) {
          window.bubble_fn_drawing_selected(drawingId);
        }
      });

      drawing.marker = newMarker;
    }

    // Update Point marker color (recreate with new SVG)
    if (drawing.type === 'point' && drawing.marker) {
      const latlng = drawing.marker.getLatLng();

      map.removeLayer(drawing.marker);

      const newPointMarker = L.marker(latlng, {
        icon: L.divIcon({
          html: '<svg width="25" height="41" viewBox="0 0 25 41" xmlns="http://www.w3.org/2000/svg">' +
            '<path d="M12.5 0C5.6 0 0 5.6 0 12.5C0 21.9 12.5 41 12.5 41S25 21.9 25 12.5C25 5.6 19.4 0 12.5 0Z" ' +
            'fill="' + newColor + '" stroke="white" stroke-width="2"/>' +
            '<circle cx="12.5" cy="12.5" r="4" fill="white"/>' +
            '</svg>',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          className: 'drawing-marker-point'
        })
      }).addTo(map);

      newPointMarker.on('click', function(e) {
        L.DomEvent.stopPropagation(e);
        if (window.bubble_fn_drawing_selected) {
          window.bubble_fn_drawing_selected(drawingId);
        }
      });

      drawing.marker = newPointMarker;
      drawing.layer = newPointMarker;
    }

    console.log('üé® Drawing color updated:', drawingId, '‚Üí', newColor);
  };

  // Update polygon fill opacity (safe to call on any type)
  window.updateDrawingOpacity = function(drawingId, newOpacity) {
    if (!window.__drawing_layers || !window.__drawing_layers[drawingId]) {
      console.warn('‚ö†Ô∏è Drawing not found:', drawingId);
      return;
    }

    const drawing = window.__drawing_layers[drawingId];

    // Only polygons have fillOpacity
    if (drawing.type === 'polygon' && drawing.layer && drawing.layer.setStyle) {
      drawing.layer.setStyle({ fillOpacity: newOpacity });
      console.log('‚ú® Polygon opacity updated:', drawingId, '‚Üí', newOpacity);
    } else {
      console.log('‚ÑπÔ∏è Opacity only applies to polygons (type:', drawing.type + ')');
    }
  };

  // ===== HELPER FUNCTIONS =====

  window.createGeoJSON = function(type, coordinates, properties) {
    return {
      type: "Feature",
      geometry: { type: type, coordinates: coordinates },
      properties: properties || {}
    };
  };

  window.calculateCenter = function(coordinates) {
    if (!coordinates || coordinates.length === 0) return null;
    let sumLat = 0, sumLng = 0;
    if (Array.isArray(coordinates[0])) {
      coordinates.forEach(coord => {
        sumLat += coord[0];
        sumLng += coord[1];
      });
    } else {
      return coordinates;
    }
    return [sumLat / coordinates.length, sumLng / coordinates.length];
  };

  // NEW: Render function for Bubble workflows
  window.renderDrawingOnMap = function(geojsonString) {
    const map = window.__leafy_found_map;
    if (!map) {
      console.error('‚ùå Map not found');
      return null;
    }

    const geojson = typeof geojsonString === 'string' ? JSON.parse(geojsonString) : geojsonString;
    const leafletCoords = geojson.geometry.coordinates.map(c => [c[1], c[0]]);

    const layer = L.polyline(leafletCoords, {
      color: geojson.properties.color || '#3B82F6',
      weight: geojson.properties.strokeWeight || 3,
      opacity: 1
    }).addTo(map);

    console.log('‚úÖ Drawing rendered on map');
    return layer;
  };

  // ===== AUTO-CAPTURE SYSTEM =====

  let captureAttempts = 0;
  const captureInterval = setInterval(function() {
    captureAttempts++;
    if (window.L && window.L.Map) installLeafletHook();
    const found = tryFindExistingMap();
    if (found) {
      clearInterval(captureInterval);
      console.log('üéâ Map capture successful! Freehand tool ready.');
      return;
    }
    if (captureAttempts >= MAX_CAPTURE_ATTEMPTS) {
      clearInterval(captureInterval);
      console.log('‚è±Ô∏è Attempts exhausted. Hook remains active.');
    }
  }, RETRY_INTERVAL_MS);

  document.addEventListener('DOMContentLoaded', function() { tryFindExistingMap(); installLeafletHook(); });
  window.addEventListener('load', function() { tryFindExistingMap(); installLeafletHook(); });

  window.__leafy_try_capture_now = function() {
    tryFindExistingMap();
    installLeafletHook();
    console.log('üîÑ Manual capture triggered.');
  };

  console.log('üöÄ Leafy Drawing Tools v4 initialized');
  console.log('üìö Available Tools:');
  console.log('  üé® Freehand:');
  console.log('    - window.__leafy_freehand.start()                    ‚Üí Draw (clears after)');
  console.log('    - window.__leafy_freehand.start({autoRender: true}) ‚Üí Draw (keeps on map)');
  console.log('  üìç Point:');
  console.log('    - window.__leafy_point.start()                       ‚Üí Place marker');
  console.log('    - window.__leafy_point.start({autoRender: true})    ‚Üí Place marker (keeps on map)');
  console.log('  üìè Line:');
  console.log('    - window.__leafy_line.start()                        ‚Üí Click vertices, dbl-click finish');
  console.log('    - window.__leafy_line.start({autoRender: true})     ‚Üí Line (keeps on map)');
  console.log('  üî∂ Area:');
  console.log('    - window.__leafy_area.start()                        ‚Üí Click vertices, dbl-click close');
  console.log('    - window.__leafy_area.start({autoRender: true})     ‚Üí Polygon (keeps on map)');
  console.log('  üßπ Utilities:');
  console.log('    - window.stopAllDrawingTools()                       ‚Üí Stop all drawing modes');
  console.log('    - window.removeDrawing(id)                           ‚Üí Remove any drawing from map');
  console.log('    - window.updateDrawingColor(id, color)               ‚Üí Update drawing color');
  console.log('    - window.updateDrawingOpacity(id, opacity)           ‚Üí Update polygon opacity');
  console.log('    - window.__leafy_freehand.clearAllRendered()        ‚Üí Clear all drawings');
  console.log('    - window.renderDrawingOnMap(geojson)                ‚Üí Render any GeoJSON');

})();
</script>
